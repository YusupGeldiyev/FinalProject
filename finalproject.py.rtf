{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 def check(vector):\par
  '''\par
  this fucntion checks if the given vectors are numbres. if value of the vectors\par
  equal numbers such as float, int or complex it returns true. othervise it prints \par
  "Invalid Input"\par
  '''\par
   # This variable will keep track of the validity of our input.\par
  inputStatus = True  \par
  # This for loop will check each element of the vector to see if it's a number. \par
  for i in range(len(vector)):  \par
    if ((type(vector[i]) != int) and (type(vector[i]) != float) and (type(vector[i]) != complex)):\par
      inputStatus = False\par
    else:\par
      return inputStatus\par
      \par
def dot(vector,vector01): \par
  '''\par
  This function takes two vectors (vector01 and vector02) as its arguments. It first checks if two vectors are the same size. \par
  If sizes are equal it then takes the dot product of two vectors then returns the result. if not it prints Error and returns none.\par
    '''\par
  if check(vector)==True:\par
    result=0\par
    a=len(vector)\par
    b=len(vector01)\par
    if (a!=b):\par
  # Here the fucntion checks if two vectors are the same size\par
      print ("Invalid Input")\par
      return None\par
    for i in range(len(vector)):\par
      result=result+vector[i]*vector01[i]\par
  # (takes the dot product of two vectors by mulyiplying each  coefficients of two vectors with each other\par
    return result\par
  else:\par
    return "The input is invalid"\par
  #returns the dot product\par
\par
vector1=[1,2,2]\par
vector2=[1,2,3]\par
vector3=[2,2]\par
vector4=[1,3,5]\par
vector6=[1]\par
vector5=[1,2]\par
#valid and invalid test values are being checked\par
#print(dot(vector1,vector2))\par
#print(dot(vector3,vector4))\par
#print(dot(vector6,vector5))\par
\par
def twoNorm(vector):\par
  '''\par
  twoNorm takes a vector as it's argument. It then computes the sum of  the squares of each element of the vector. It then returns the square root of this sum.\par
  '''\par
  if check(vector) == True:\par
    result = 0\par
# This for loop will compute the sum of the squares of the elements of the vector. \par
    for i in range(len(vector)):\par
      result = result + (vector[i]**2)\par
    result = result**(1/2)\par
    return result\par
  else:\par
    return "Invalid Input"\par
vector1=[1,2,2]\par
vector2=1\par
#print (twoNorm(vector1))\par
#print (twoNorm(vector2))\par
\par
def orthogonVector(vector):\par
  '''\par
  This function takes a vector as its argument. it then divides every element of that vector by two norm of that vector. and returns updated orthogonalized vector back\par
    '''\par
  if check(vector)==True:\par
    norm=twoNorm(vector)\par
  # function that calculates two norm is being assigned\par
    orthogonalizedVector=[]\par
  #assigning empty list for new orthog vector\par
    for i in range(len(vector)):\par
      newvector=((1/norm))*vector[i]\par
  #dividing vector values by two  norm\par
      orthogonalizedVector.append(newvector)\par
    #returning back to assigned empty\par
    return orthogonalizedVector\par
  else:\par
    return "Invalid Input"\par
vector1=[1,2,2]\par
test2=123\par
#testing valid and not valid inputs\par
#print(orthogonVector(vector1))\par
#print(orthogonVector(test2))\par
\par
def scalarVecMulti(scalar,vector): \par
  '''\par
  This function takes a scalar and a vector as its arguments. Then it multiplies scalar and a vector and returns the updated vector.\par
  ''' \par
  if check(vector)==True:\par
    result=[]\par
  # creating empty list to return the result after calculation so it puts back a new vector\par
    for i in range(len(vector)):\par
      total=0\par
      total=scalar*vector[i]\par
  # vector scalar multiplication\par
      result.append(total)\par
    return result #returns the new vector\par
  else:\par
    return "Invalid Input"\par
  \par
\par
# the test values wtih scalar and  different size vectors  are being checked.\par
scalar=2\par
vector2=[1,2,3]\par
vector3=[1,2]\par
vector4=[1,3,5]\par
#print(scalarVecMulti(scalar,vector2))\par
#print(scalarVecMulti(vector3,vector4))\par
\par
def vecSubtract(vector,vector1): \par
  '''\par
This function takes two vectors (vector01 and vector02) as its arguments. It first checks if two vectors are the same size. \par
If sizes are equal it then subtracts vector02 from vector01,then returns the result which is vector. if not it prints Error retruns None".\par
  '''\par
  inputStatus = True\par
  if check(vector)== False:\par
    inputStatus=False\par
  if inputStatus== True:\par
    inputStatus==check(vector1)\par
  if inputStatus==True:\par
    result=[]\par
    # assigning an empty list to get back a new vector after calculations\par
    a=len(vector)\par
    b=len(vector1)\par
    if (a!=b):\par
   # Here the fucntion checks if two vectors are the same size\par
      print ("Error")\par
      return None\par
    for i in range(len(vector)):\par
      total=0\par
      total+=vector[i]-vector1[i]\par
      # vector subtraction\par
      result.append(total)\par
    return result\par
  #returns the new subtracted vector\par
  else:\par
    return "Invalid Input"\par
vector1=[1,2,5]\par
vector2=[1,2,3]\par
vector3=[1,2]\par
vector4=[1,3,5]\par
#print(vecSubtract(vector1,vector2))\par
# the test values wtih right and not right vector sizes are being checked.\par
#print(vecSubtract(vector3,vector4))\par
\par
def GST(A):\par
  '''\par
  This function takes given matrix A and uses above mentioned functions to calculate\par
  QR factorization(gram schmidt) of that given matrix. It creates R, Q with all zeroes\par
  then it computes both matrix arguments and returns it back.\par
  '''\par
  #rows of matrix A\par
  m=len(A[0])\par
  #columns of matrix A\par
  n=len(A)\par
  V=A\par
  #V are the vectors of A\par
  #creates empty matrices R and Q\par
  R=[[0]*n for i in range(n)]\par
  Q=[[0]*m for i in range(n)]\par
  for i in range(n):\par
    #this for loop calculates r11 and q1\par
    R[i][i]=twoNorm(V[i])\par
    Q[i]=orthogonVector(V[i])\par
    for j in range(i+1,n):\par
      #this for loops computes r12,r22 and q 2\par
      R[j][i]=dot(Q[i],V[j])\par
      temp=scalarVecMulti(R[j][i],Q[i])\par
      V[j]=vecSubtract(V[j],temp)    \par
  return [Q,R]\par
A=[[1,1,1,1,1,1,1,1,1,1],[0.55,0.60,0.65,0.70,0.75,0.80,0.85,0.90,0.95,1.00],[0.3025,0.36,0.4225,0.49,0.5625,0.64,0.7225,0.81,0.9025,1.00],[0.166375, 0.216, 0.274625, 0.343, 0.421875, 0.512, 0.614125, 0.729, 0.857375, 1.00]]\par
print(GST(A))\par
\par
\par
def TmatVec(A,vector): \par
  '''This fucntion takes arguments A as a matrix and vector. and makes Matrix and Vector multiplication. that obeys mat vec mult rule which described in checks. it calcualtes transpose of matrix of vector m given mat veector\par
  '''\par
 \par
  for i in range(len(A)):\par
    for j in range(len(A[0])):\par
      if ((type(A[i][j]) != int) and (type(A[i][j]) != float) and (type(A[i][j]) != complex)):\par
        print ("Invalid Input")\par
  if check(vector)==True:\par
    result = [] \par
    for i in range(len(A)): # runs for the raws of new vector        \par
      total = 0     \par
      for j in range(len(vector)):         #runs for the columns of new vector        \par
        total+=A[i][j] *vector[j] \par
      result.append(total)\par
   # the amount of columns in the matrix hast to be the amount as the raws in the vector \par
  return result \par
vector1=[1,2,3]\par
matrix=[[1,2,3],[0,0,0],[1,1,1]]\par
#print(TmatVec(matrix,vector1))\par
\par
\par
def Backsub(R,b):\par
  '''\par
  This function takes a matrix and a vector as its arguments and computes the backsubstitution to get c vector.\par
  '''\par
 \par
  #identifying vector to access variables of vector\par
  R=len(b)-1\par
  #creates empty vector\par
  c=[0]*len(b)\par
  #division\par
  c[R] = b[R]/ R[R][R]\par
  #the for loop to compute c\par
  for i in reversed(range(len(b))):\par
    c[i]=b[i]\par
    for j in range(i+1,len(b)):\par
      c[i]=c[i]-(c[j]*R[j][i])\par
      c[i]=c[i]/R[i][i]\par
  return c\par
\par
\par
A=[[1,1,1,1,1,1,1,1,1,1], \par
[0.55,0.60,0.60,0.65,0.70,0.75,0.80,0.85,0.90,0.95,1.00], \par
[0.3025,0.36,0.4225,0.49,0.5625,0.64,0.7225,0.81,0.9025,1.00], \par
[0.166375, 0.216, 0.274625, 0.343, 0.421875, 0.512, 0.614125, 0.729, 0.857375, 1.00]]\par
\par
X=[0.55,0.60,0.65,0.70,0.75,0.8,0.85,0.9,0.95,1]\par
y=[1.102,1.099,1.017,1.111,1.136,1.265,1.380,1.375,1.857]\par
\par
GS_Solution=GST(A)\par
Q=GS_Solution[0]\par
R=GS_Solution[1]\par
b=TmatVec(Q,y) \par
c=Backsub(R,b)\par
\par
print(c)\par
}
 